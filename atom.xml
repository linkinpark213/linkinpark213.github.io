<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linkin213&#39;s Park</title>
  
  <subtitle>Blog of linkinpark213</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linkinpark213.com/"/>
  <updated>2018-04-29T14:05:43.898Z</updated>
  <id>http://linkinpark213.com/</id>
  
  <author>
    <name>Harper Long</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A Painless Tensorflow Basic Tutorial - Take ResNet-56 as an Example</title>
    <link href="http://linkinpark213.com/2018/04/29/diy-resnet/"/>
    <id>http://linkinpark213.com/2018/04/29/diy-resnet/</id>
    <published>2018-04-29T14:05:43.000Z</published>
    <updated>2018-04-29T14:05:43.898Z</updated>
    
    <content type="html"><![CDATA[<p><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><br></p><p lang="en-us">TensorFlow is a powerful open-source deep learning framework, supporting various languages including Python. However, its APIs are far too complicated for a beginner in deep learning(especially those who are new to Python). In order to ease the pain of having to understand the mess of various elements in TensorFlow computation graphs, I made this tutorial to help beginners take the first bite of the cake.<br>ResNets are one of the greatest works in the deep learning field. Although they look scary with extreme depths, it&#39;s not a hard job to implement one. Now let&#39;s build one of the simplest ResNets - ResNet-56, and train it on the CIFAR-10 dataset.<br></p><a id="more"></a><p lang="zh-cn">TensorFlow是一个强大的开源深度学习软件库，它支持包括Python在内的多种语言。然而，由于API过于复杂（实际上还有点混乱），它往往使得一个深度学习的初学者（尤其是为此初学Python的那些）望而却步——老虎吃天，无从下口。为了减轻初学者不得不尝试理解TensorFlow中的大量概念的痛苦，我213今天带各位尝尝深度学习这片天的第一口。ResNet是深度学习领域的一个重磅炸弹，尽管它们（ResNet有不同层数的多个模型）的深度看上去有点吓人，但实际上实现一个ResNet并不难。接下来，我们来实现一个较为简单的ResNet——ResNet-56，并在CIFAR-10数据集上训练一下，看看效果如何。</p><div align="center" class="figure"><img src="/images/tftutorial/oyo.gif" alt="Let&#39;s Rock!"></div><p lang="en-us">First let&#39;s take a look at ResNet-56. It&#39;s proposed by Kaiming He et al., and is designed to confirm the effect of residual networks. It has 56 weighted layers, deep but simple. The structure is shown in the figure below:</p><p lang="zh-cn">首先来看一下ResNet-56这个神经网络。它是何凯明等在ResNet论文中提出的、用于验证残差网络效果的一个相对简单的残差网络（尽管它很深，深度达到了56个权重层）。图示如下：</p><div align="center" class="figure"><img src="/images/tftutorial/resnet56.png" alt="ResNet-56" width="80%"><br>Fig. 1 The structure of ResNet-56</div><br><p lang="en-us">Seems a little bit long? Don&#39;t worry, let&#39;s do this step by step.</p><p lang="zh-cn">看起来有点长了是不是？别担心，我们一步一步来做。</p><h2 id="1-Ingredients"><a href="#1-Ingredients" class="headerlink" title="1 Ingredients"></a>1 Ingredients</h2><p>Python 3.6</p><p>TensorFlow 1.4.0</p><p>Numpy 1.13.3</p><p>OpenCV 3.2.0</p><p><a href="https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz" target="_blank" rel="noopener">CIFAR-10 Dataset</a></p><p lang="en-us">Also prepare some basic knowledge on Python programming, digital image processing and convolutional neural networks. If you are already capable of building, training and validating your own neural networks with TensorFlow, you don&#39;t have to read this post.</p><p lang="zh-cn">另外，请确保自己有一点点Python编程、数字图像处理和卷积神经网络的知识储备。如果你已经具备用TensorFlow自行搭建神经网络并进行训练、测试的能力，就不必阅读本文了。</p><h2 id="2-Recipe"><a href="#2-Recipe" class="headerlink" title="2 Recipe"></a>2 Recipe</h2><h3 id="2-0-Prepare-the-tools"><a href="#2-0-Prepare-the-tools" class="headerlink" title="2.0 Prepare the tools"></a>2.0 Prepare the tools</h3><p lang="en-us">Prepare(import) the tools for our project, including all that I mentioned above. Like this :P</p><p lang="zh-cn">准(i)备(m)所(p)需(o)工(r)具(t)，上一部分已提到过。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> tensor_chain <span class="keyword">import</span> TensorChain</span><br></pre></td></tr></table></figure><br><p lang="en-us">Wait... What&#39;s this? TensorChain? Another deep learning framework like TensorFlow?<br>Uh, nope. This is my own encapsulation of some TensorFlow APIs, for the sake of easing your pain. You&#39;ll only have to focus on &quot;what&#39;s what&quot; in the beginning. We&#39;ll look into my implementation of this encapsulation later, when you are clear how everything goes. Please <a href="/files/tensor_chain.py">download this file</a> and put it where your code file is, and import it.</p><p lang="zh-cn">等等...最后这个是个什么鬼？ TensorChain？另一个深度学习框架吗？<br>呃...并不是。这个是我对一些TensorFlow API的封装，为了减轻你的痛苦才做的。作为初学者，你只需要关注用TensorFlow搭建网络模型的这个过程，分清东西南北。回头等你弄清了大体流程后，我们再来看这个的实现细节。请先下载<a href="/files/tensor_chain.py">这个文件</a>并把它与你的代码放在同一文件夹下，然后就可以import了。</p><h3 id="2-1-Decide-the-input"><a href="#2-1-Decide-the-input" class="headerlink" title="2.1 Decide the input"></a>2.1 Decide the input</h3><p lang="en-us">Every neural network requires an input - you always have to identify the details of a question, before asking the computer to solve it. All of the variable, constant in TensorFlow are objects of type <em>tf.Tensors</em>. And the <em>tf.placeholder</em> of our input(s) is a special one. Images in CIFAR-10 dataset are RGB images(3 channels) of 32x32(really small), so our input should shaped like [32, 32, 3]. Also, we want to input a little <em>batch</em> of multiple images. Therefore, our input data should be an array of shape <em>[?, 32, 32, 3]</em>. Unknown dimension size can be marked as None, and it will be clear when we feed the model with the actual images. It&#39;s coded like this:</p><p lang="zh-cn">每个神经网络都需要有输入——毕竟你想找电脑解决一些问题的话，你总得告诉它问题的一些细节吧？TensorFlow中所有的变量、常量都是<em>tf.Tensor</em>类型的对象，作为输入内容的占位符<em>tf.placeholder</em>也是（只不过比较特殊而已）。CIFAR-10数据集的图像都是32x32尺寸（好小哇）的RGB图像（RGB即彩色图像的三个通道），因此我们的输入给神经网络的内容将会像是[32, 32, 3]这个样子。另外呢，我们需要输入的是一个小<em>batch</em>（批）的图像，因此，输入网络的图像数据将会是一个<em>[?, 32, 32, 3]</em>的数组（也可以是numpy数组）。未知的维度大小用None代指就好，我们之后给模型喂实际图像batch时，它自然就清楚了。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_tensor = tf.placeholder(dtype=tf.float32, shape=[<span class="keyword">None</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><br><p lang="en-us"><em>Ground truth</em> data also need to be known in supervised learning, so we also have to define a placeholder for the ground truth data:<br></p><p lang="zh-cn">监督学习中，正确标注的数据（英文为<em>ground truth</em>，目前貌似没有对这个名词的合理翻译）也是需要输入到模型中的。因此再给ground truth定义一个placeholder：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ground_truth = tf.placeholder(dtype=tf.float32, shape=[<span class="keyword">None</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><br><p lang="en-us">We want the label data to be in the one-hot encoding format, which means an array of length 10, denoting 10 classes. Only on one position is a &#39;1&#39;, and on other positions are &#39;0&#39;s.</p><p lang="zh-cn">我们需要标记的数据呈One-Hot编码格式（又称为一位有效编码），意思是如果有10个类别，那么数组长度就是10，每一位代表一个类别。只有一个位置上是1（代表图片被分为这个类），其他位上都是0。</p><h3 id="2-2-Do-some-operations"><a href="#2-2-Do-some-operations" class="headerlink" title="2.2 Do some operations"></a>2.2 Do some operations</h3><p lang="en-us">For now, let&#39;s use our TensorChain to build it fast. Under most circumstances that we may face, the computations are based on the input data or the result of the former computation, so our network(or say, the most of it) look more like a chain than a web. Every time we add some new operation(layer), we add it to our <em>TensorChain</em> object. Just remember to get the <em>output_tensor</em> of this object(denoting the output tensor of the last operation on the chain) when you need to ue native TensorFlow API.The construction function of TensorChain class requires a Tensor object as the parameter, which is also the input tensor of this chain. As we mentioned earlier, all we have to do is add operations. See my ResNet-56 code:</p><p lang="zh-cn">现在呢，我们先用TensorChain来快速盖楼。因为我们遇到的大多数情况下，所有的计算都是在输入数据或者这个计算的前一个计算结果基础上进行的，所以我们的网络（至少是它的绝大部分）会看起来像个链而不是所谓的网。每次我们添加一个新的运算（层），我们会把它加到这个独一无二的TensorChain对象。只要记得在使用原生TensorFlow API前把它的<em>output_tensor</em>属性（也就是这条链上最后一个运算的输出Tensor）取出来就好了。TensorChain类的构造函数需要一个Tensor对象作为参数，这个对象也正是被拿来作为这个链的输入层。正如我们之前所说的，只要在这个对象上添加运算即可。写个ResNet-56，代码很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">chain = TensorChain(input_tensor) \</span><br><span class="line">        .convolution_layer_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>, stride=<span class="number">2</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>, stride=<span class="number">2</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">        .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">        .flatten() \</span><br><span class="line">        .fully_connected_layer(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><br><p lang="en-us">This is it? Right, this is it! Isn&#39;t it cool? Didn&#39;t seem that high, huh? That&#39;s because I encapsulated that huge mess of weights and biases, only leaving a few parameters that decide the structure of the network. Later in this pose we&#39;ll talk about the actual work that these functions do.</p><p lang="zh-cn">就这？没错呀，就这！稳不稳？似乎看起来也没56层那么高呀？毕竟这些函数被我封装得太严实了，只留出几个决定网络结构的几个参数供修改。这篇博客后边就会讲到这些函数究竟干了点什么事儿。</p><h3 id="2-3-Define-the-loss"><a href="#2-3-Define-the-loss" class="headerlink" title="2.3 Define the loss"></a>2.3 Define the loss</h3><p lang="en-us">In supervised learning, you always have to tell the learning target to the model. To tell the model how to optimize, you have to let it know how, how much, on which direction should it change its parameters. This is done by using a loss function. Therefore, we need to define a loss function for our ResNet-56 model(which we designed for this classification problem) so that it will learn and optimize.A commonly used loss function in classification problems is cross entropy. It&#39;s defined below:</p><p lang="zh-cn">搞监督学习，总是要让模型按照“参考答案”去改的。要改就得让它知道怎么改、改多少、往什么方向改，这也就是<em>loss</em>（损失函数）的功劳。因此，像我们这个拿来做分类问题的ResNet-56，我们要给它定义一个损失函数来让它学习、优化。分类问题上一个常用的损失函数是交叉熵。定义如下式：</p>$$C=-\frac{1}{n}\sum_x{y\ln a+(1-y)\ln(1-a)}$$<p lang="en-us">in which \(y\) is the expected(or say correct) output and \(a\) is the actual output.This seems a little bit complicated. But it&#39;s not a hard job to implement, since TensorFlow implemented it already! You can also try and implement it yourself within one line if you want. For now we use the pre-defined cross entropy loss function:</p><p lang="zh-cn">其中\(y\)为期望输出（或者说参考答案），\(a\)为实际输出。略复杂呀...这个用程序怎么写？其实也不难。。。毕竟TensorFlow都帮我们实现好啦！（有兴趣的话也可以自己尝试着写一下，同样一行代码即可搞定）现在你只需要来这么一句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = tf.reduce_mean(tf.losses.softmax_cross_entropy(ground_truth, prediction))</span><br></pre></td></tr></table></figure><br><p lang="en-us">and it returns a tf.Tensor that denotes an average of cross entropies(don&#39;t forget that this is a batch). As for the &#39;softmax&#39; before the &#39;cross_entropy&#39;, it&#39;s a function that project the data in an array to range 0~1, which allows us to do a comparison between our prediction and the ground truth(in one-hot code). The definition is simple too:<br></p><p lang="zh-cn">就可以创建一个表示交叉熵平均值（别忘了这可是一个batch）的Tensor了。至于cross_entropy前边的那个<em>softmax</em>呢，它的作用是把输入的数组内数据归一化，投射到0~1的范围内（实际上就是相当于把exp(数组各项的值)的当做频数，求出一个概率），这样子才能跟实际数据做一个比较。定义也比较简单：<br></p>$$S_i=\frac{e^{V_i}}{\sum_j{e^{V_j}}}$$<p></p><h3 id="2-4-Define-the-train-op"><a href="#2-4-Define-the-train-op" class="headerlink" title="2.4 Define the train op"></a>2.4 Define the train op</h3><p lang="en-us">Now we have the loss function. We&#39;ll have to tell its value to an <em>optimizer</em>, which make our model learn and optimize in order to minimize the loss value. Gradient Descent Optimizer, Adagrad Optimizer, Adam Optimizer and Momentum Optimizer are commonly used optimizers. Here we use an Adam Optimizer for instance. You&#39;re free to try any other one here. When</p><p lang="zh-cn">现在误差函数已经有了，我们需要把它的值告诉一个优化器（<em>optimizer</em>），并让它去尽可能向着缩小误差函数值得方向努力。这样，模型才能去学习、优化。常用的优化器包括Gradient Descent Optimizer，Adagrad Optimizer，Adam Optimizer以及Momentum Optimizer等等等等。选择优化器时，我们需要给它一个初始的学习速率。这里我用了一个\(10^-3\)，如果需要提高准确率，可能后期微调还需要进一步减小。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><br><p lang="en-us">Also, tell the optimizer that what the loss tensor is. The returned object is a train operation.</p><p lang="zh-cn">当然还要告诉它要减小的损失函数是哪个Tensor，这个函数返回的是一个训练操作（<em>train op</em>，一种特殊的运算，或者说操作）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train = optimizer.minimize(loss)</span><br></pre></td></tr></table></figure><br><p lang="en-us">The neural network is finished. It&#39;s time to grab some data and train it.</p><p lang="zh-cn">其实到这里为止，神经网络已经搭建好了。是时候搞点数据来训练它了。</p><h3 id="2-5-Feed-the-model-with-data-and-train-it"><a href="#2-5-Feed-the-model-with-data-and-train-it" class="headerlink" title="2.5 Feed the model with data, and train it!"></a>2.5 Feed the model with data, and train it!</h3><p lang="en-us">Remember how we defined the placeholders? It&#39;s time to fetch some data that fits the placeholders and train it. See how CIFAR-10 dataset can be fetched on its <a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">website</a><br></p><p lang="zh-cn">还记得我们怎么定义那些placeholder吗？现在我们要把符合它们口径的数据灌进模型。那么来看一下CIFAR-10数据集<a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">官网</a>上是怎么描述的吧。它给了这么一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpickle</span><span class="params">(file)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">'rb'</span>) <span class="keyword">as</span> fo:</span><br><span class="line">        dict = pickle.load(fo, encoding=<span class="string">'bytes'</span>)</span><br><span class="line">    <span class="keyword">return</span> dict</span><br></pre></td></tr></table></figure><br><p lang="en-us">The returned value <em>dict</em> is a Python dictionary. Every time we unpickle a file, a dictionary would be returned. Its &#39;data&#39; key leads to 10000 RGB images of size 32x32, which is stored in a [10000, 3072] array(3072=32<em>32</em>3, I guess you know how it&#39;s stored now). The &#39;label&#39; key leads to 10000 values in range 0~9. Obviously we have to reshape the data so as to fit it into the network model:</p><p lang="zh-cn">返回值<em>dict</em>是一个字典（Python的dict类型）。每读一个batch文件（比如data_batch_1），就会返回这样一个字典，它的“data”键值是10000张32x32的RGB图像（数组维数居然是[10000, 3072]，而3072=10000x32x32x3！实际上就是直接把所有像素、所有通道的值罗列在这里了）；“label”键值是10000个0-9之间的整数（代表类别）。显然，为了让数据能够成功放进模型，还需要对它进行一点处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">batch = unpickle(DATA_PATH + <span class="string">'data_batch_&#123;&#125;'</span>.format(i))  <span class="comment"># 'i' is the loop variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read the image data</span></span><br><span class="line">image_data = np.reshape(batch[<span class="string">b'data'</span>], (<span class="number">10000</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>), <span class="string">'F'</span>).astype(np.float32)   </span><br><span class="line">image_data = image_data / <span class="number">255</span>                            <span class="comment"># Cast range(0, 255) to range(0, 1)</span></span><br><span class="line">image_data = np.transpose(image_data, (<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>))      <span class="comment"># Exchange row and column</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read the label data and convert into one-hot code</span></span><br><span class="line">label_data = batch[<span class="string">b'labels'</span>]</span><br><span class="line">new_label_data = np.zeros((<span class="number">10000</span>, <span class="number">10</span>))                   </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    new_label_data[j][label_data[j]] = <span class="number">1</span></span><br></pre></td></tr></table></figure><br><p lang="en-us">The details for data processing are not covered here. Try doing step-by-step to see the results.The <em>image_data</em> and <em>new_label_data</em> are contain 10000 pieces of data each. Let&#39;s divide them into 100 small batches(100 elements each, including image and label) and feed it into the model. Do this on all the 5 batch files:</p><p lang="zh-cn">处理的细节不再赘述。你可以尝试一步一步运行来看看每一步的结果。这样我们拿到的<em>image_data</em>和<em>new_label_data</em>都是长度为10000的大batch，我们把它们各自分成100份，每次取100个图像+标记数据来塞进模型。对全部5个大batch文件来一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    session.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment"># 10000 / BATCH_SIZE</span></span><br><span class="line">        <span class="comment"># Divide them and get one part</span></span><br><span class="line">        image_batch = image_data[j * BATCH_SIZE: j * BATCH_SIZE + BATCH_SIZE]</span><br><span class="line">        label_batch = new_label_data[j * BATCH_SIZE: j * BATCH_SIZE + BATCH_SIZE]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Feed the model</span></span><br><span class="line">        session.run(train, feed_dict=&#123;</span><br><span class="line">            input_tensor: image_batch,</span><br><span class="line">            ground_truth: label_batch</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><br><p lang="en-us">A <em>session</em> - created with <em>tf.Session()</em> - is required every time we run a TensorFlow model, no matter when we&#39;re training it or evaluating it. The first time you run a model, you&#39;ll need to run <em>session.run(tf.global_variables_initializer())</em> to initialize the values of the TensorFlow variables defined previously.When running <em>session.run()</em>, you must first decide a TensorFlow operation(or a list of operations) that you need. If its result is dependent on some actual data(which means that some data in one or more placeholders flow to this operation), it&#39;s also required that you feed it the actual data by adding a <em>feed_dict</em> parameter. For example, I&#39;m training this ResNet-56 model, in which a loss will be calculated with my <em>ground_truth</em> and the prediction result that comes from the <em>input_tensor</em>. Therefore, I&#39;ll have to give a value for each placeholder given above(format: &quot;placeholder name: corresponding data&quot;), and fold them in one Python dictionary.</p><p lang="zh-cn">每次运行一个TensorFlow模型（无论是训练还是测试）时，都需要通过tf.Session()创建一个<em>session</em>。第一次运行模型（而不是载入之前保存的模型）时，需要使用<em>session.run(tf.global_variables_initializer())</em>来初始化之前定义的一些可训练的TensorFlow变量。运行<em>session.run()</em>时，需要指定一个或一组你要执行的operation，作为这个函数唯一一个必要的参数。如果它的结果依赖于一些实际数据（也就是说在计算图中，一些数据会从placeholder流向这个operation），那么就需要通过填入<em>feed_dict</em>参数的值来填装训练或测试数据。以此模型为例，我在训练它时需要算误差函数值，这需要<em>ground_truth</em>数据和预测结果来计算，而预测结果又需要用输入图像<em>input_tensor</em>来计算得到。因此，我需要给这两个占位符分别给出对应的数据（格式：“占位符名：对应数据”），并把它们封在同一个Python字典中作为feed_dict参数的值。</p><p lang="en-us">I&#39;m also interested in the loss function value in each iteration(which means feeding a batch of data and executing one forward-propagation and one back-propagation) in the training process. Therefore, what I&#39;ll fill in the parameter is not just the train op, but also the loss tensor. And the session.run() above should be modified to:</p><p lang="zh-cn">然而呢，我还想看看每次迭代（即把一个batch送进去，执行一次正向传播与反向传播这个过程）中损失函数变成了多大，来监控一下训练的效果。这样，需要session.run()的就不仅是那个train运算，还要加上loss运算。将上边的session.run()部分改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[train_, loss_value] = session.run([train, loss],</span><br><span class="line">    feed_dict=&#123;</span><br><span class="line">        input_tensor: image_batch,</span><br><span class="line">        ground_truth: label_batch</span><br><span class="line">    &#125;)</span><br><span class="line">print(<span class="string">"Loss = &#123;&#125;"</span>.format(loss_value)</span><br></pre></td></tr></table></figure><br><p lang="en-us">This is when the return value of session.run() becomes useful. Its value(s) - corresponding to the first parameter of run() - is/are the actual value(s) of the tensor(s) in the first parameter. In our example, <em>loss_value</em> is the actual output of the loss tensor. As for train_, we don&#39;t care what it is. Just add it to match the dimensions.</p><p lang="zh-cn">这时候，session.run()函数的返回值就有意义了。它与第一个参数的内容一一对应，分别是该参数中各个operation的实际输出值。像这个例子里边，<em>loss_value</em>接收的就是loss运算的输出内容。而train运算的输出我们并不关心，但是为了保证参数维度数与返回值一致，用一个train_变量来接收而已（实际上它的值是None）。</p><p lang="en-us">Actually, one epoch(train the model once with the whole dataset) is not enough for the model to fully optimize. I trained this model for 40 epochs and added some loop variables to display the result. You can see my code and my output below. It&#39;s highly recommended that you train this with a high-performance GPU, or it would be a century before you train your model to a satisfactory degree.</p><p lang="zh-cn">实际上，一个epoch（把整个数据集都在模型里过一遍的周期）并不足以让模型充分学习。我把这个模型训练了40个epoch并且加了一些循环变量来输出结果。我的代码和结果如下。强烈建议用一个高性能GPU训练（如果手头没有，可以租一个GPU服务器），不然等别人把毕设论文逗写完的时候，你还在训练就很尴尬了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> tensor_chain <span class="keyword">import</span> TensorChain</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpickle</span><span class="params">(file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">'rb'</span>) <span class="keyword">as</span> fo:</span><br><span class="line">        dict = pickle.load(fo, encoding=<span class="string">'bytes'</span>)</span><br><span class="line">    <span class="keyword">return</span> dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    input_tensor = tf.placeholder(dtype=tf.float32, shape=[<span class="keyword">None</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>])</span><br><span class="line">    ground_truth = tf.placeholder(dtype=tf.float32, shape=[<span class="keyword">None</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">    chain = TensorChain(input_tensor) \</span><br><span class="line">            .convolution_layer_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">16</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>, stride=<span class="number">2</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">32</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>, stride=<span class="number">2</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">            .residual_block_2d(<span class="number">3</span>, <span class="number">64</span>) \</span><br><span class="line">            .flatten() \</span><br><span class="line">            .fully_connected_layer(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    prediction = chain.output_tensor</span><br><span class="line">    loss = tf.reduce_mean(tf.losses.softmax_cross_entropy(ground_truth, prediction))</span><br><span class="line"></span><br><span class="line">    optimizer = tf.train.AdamOptimizer(learning_rate=<span class="number">0.001</span>)</span><br><span class="line">    train = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">        session.run(tf.global_variables_initializer())</span><br><span class="line">        iteration = <span class="number">1</span></span><br><span class="line">        BATCH_SIZE = <span class="number">100</span></span><br><span class="line">        DATA_PATH = <span class="string">'../data/cifar-10-batches-py/'</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">41</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">                data = unpickle(DATA_PATH + <span class="string">'data_batch_&#123;&#125;'</span>.format(i))</span><br><span class="line">                image_data = np.reshape(data[<span class="string">b'data'</span>], (<span class="number">10000</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>), <span class="string">'F'</span>).astype(np.float32)</span><br><span class="line">                image_data = image_data / <span class="number">255</span></span><br><span class="line">                image_data = np.transpose(image_data, (<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">                label_data = data[<span class="string">b'labels'</span>]</span><br><span class="line">                new_label_data = np.zeros((<span class="number">10000</span>, <span class="number">10</span>))</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">                    new_label_data[j][label_data[j]] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(int(<span class="number">10000</span> / BATCH_SIZE)):</span><br><span class="line">                    image_batch = image_data[j * BATCH_SIZE: j * BATCH_SIZE + BATCH_SIZE]</span><br><span class="line">                    label_batch = new_label_data[j * BATCH_SIZE: j * BATCH_SIZE + BATCH_SIZE]</span><br><span class="line">                    [train_, loss_] = session.run(</span><br><span class="line">                        [train, loss],</span><br><span class="line">                        feed_dict=&#123;</span><br><span class="line">                            input_tensor: image_batch,</span><br><span class="line">                            ground_truth: label_batch</span><br><span class="line">                        &#125;)</span><br><span class="line">                    iteration += <span class="number">1</span></span><br><span class="line">                    print(<span class="string">"Epoch &#123;&#125;, Iteration &#123;&#125;, Loss = &#123;&#125;"</span>.format(epoch, iteration, loss_))</span><br></pre></td></tr></table></figure><br><div align="center" class="figure"><img src="/images/tftutorial/train.png" alt="Training result" width="40%"><br>Fig. 2 Training result: cross entropy has dropped below 0.5</div><p></p><h3 id="2-6-Conclusion"><a href="#2-6-Conclusion" class="headerlink" title="2.6 Conclusion"></a>2.6 Conclusion</h3><p lang="en-us">In a word, building &amp; training neural network models with TensorFlow involves the following steps:<br>1. Decide the <em>input tensor</em><br>2. Add operations(<em>op</em>s) based on existing tensors<br>3. Define the <em>loss</em> tensor, just like other tensors<br>4. Select an <em>optimizer</em> and define the <em>train</em> op<br>5. Process <em>data</em> and feed the model with them</p><p lang="zh-cn">总而言之，用TensorFlow建立、训练一个神经网络模型分以下几步：<br>1. 定义<em>输入</em>Tensor<br>2. 在已有的Tensor上添加运算（<em>op</em><br>3. 像之前添加的那些运算一样，定义<em>损失</em>Tensor<br>4. 选择一个<em>优化器</em>并定义<em>训练</em>操作<br>5. 把<em>数据</em>处理为合适的shape，并喂进模型训练</p><h2 id="3-A-Closer-Look"><a href="#3-A-Closer-Look" class="headerlink" title="3 A Closer Look"></a>3 A Closer Look</h2><p lang="en-us">Wait, it&#39;s too late to leave now<br>TensorChain saved you from having to deal with a mess of TensorFlow classes and functions. Now it&#39;s time that we take a closer look at how TensorChain is implemented, thus understanding the native TensorFlow APIs.</p><p lang="zh-cn">别走呢喂！TensorChain让你不至于面对TensorFlow中乱糟糟的类型和函数而不知所措被水淹没。现在是时候近距离观察一下TensorChain是如何实现的，以便理解TensorFlowAPI了。</p><h3 id="3-1-TensorFlow-variables"><a href="#3-1-TensorFlow-variables" class="headerlink" title="3.1 TensorFlow variables"></a>3.1 TensorFlow variables</h3><p lang="en-us">Let&#39;s begin with TensorFlow variables. Variables in TensorFlow are similar to variables in C, Java or any other strong typed programming languages - they have a type, though not necessarily explicitly decided upon definition. Usually them will change as the training process goes on, getting close to a best value.The most commonly used variables in TensorFlow are weights and biases. I guess that you have seen formulae like:</p><p lang="zh-cn">先说TensorFlow的变量。TensorFlow的变量和C，Java以及其他强类型语言类似——都有一个类型，尽管不一定在它的定义时就显式地声明。通常它们会随着训练的进行而不断变化，达到一个最佳的值附近。TensorFlow中最常用的变量就是weights和biases（权重和偏置）。想必你应该见过这样的式子吧：</p>$$y=Wx+b$$<p lang="en-us">The \(W\) here is the weight, and the \(b\) here is the bias. When implementing some common network layers, they two are always used as the parameters in the layers. For instance, at the very beginning of our ResNet-56, we had a 3x3 sized convolution layer with 16 channels. Its implementation in TensorChain is:</p><p lang="zh-cn">这里\(W\)就是权重，\(b\)就是偏置。在定义一些常用的层时，我们往往也是用这两个变量作为这些层中的参数。比如说，在我们ResNet-56最开始，我们用到了一个3x3大小、16个通道的卷积层，TensorChain中，它的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convolution_layer_2d</span><span class="params">(self, filter_size: int, num_channels: int, stride: int = <span class="number">1</span>, name: str = None,</span></span></span><br><span class="line"><span class="function"><span class="params">                         disable_log: bool = False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Add a 2D convolution layer</span></span><br><span class="line"><span class="string">    :param filter_size: Filter size(width and height) for this operation</span></span><br><span class="line"><span class="string">    :param num_channels: Channel number of this filter</span></span><br><span class="line"><span class="string">    :param stride: Stride for this convolution operation</span></span><br><span class="line"><span class="string">    :param name: The name of the tensor</span></span><br><span class="line"><span class="string">    :param disable_log: Set it True if you don't want this layer to be recorded</span></span><br><span class="line"><span class="string">    :return: This object itself</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    filter = self._weights([filter_size, filter_size, self.num_channels, num_channels], layer_name=name,</span><br><span class="line">                           suffix=<span class="string">'filter'</span>)</span><br><span class="line">    bias = self._bias([num_channels], layer_name=name)</span><br><span class="line">    self.num_channels = num_channels</span><br><span class="line">    self.output_tensor = tf.nn.conv2d(self.output_tensor, filter,</span><br><span class="line">                                      [<span class="number">1</span>, stride, stride, <span class="number">1</span>], <span class="string">'SAME'</span>, name=name)</span><br><span class="line">    self.output_tensor = tf.add(self.output_tensor, bias)</span><br><span class="line">    self._log_layer(</span><br><span class="line">        <span class="string">'2D Convolution layer, filter size = &#123;&#125;x&#123;&#125;, stride = &#123;&#125;, &#123;&#125; channels'</span>.format(filter_size, filter_size,</span><br><span class="line">                                                                                     stride,</span><br><span class="line">                                                                                     num_channels),</span><br><span class="line">        disable=disable_log)</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><br><p lang="en-us">See? On line 16, we used a <em>tf.nn.conv2d()</em> function, the parameters of which are <em>input</em>, <em>filter</em>, <em>strides</em>, <em>padding</em>, etc. As can be guessed from the names, this function does a convolution operation with out input and the weights(the convolution <em>filter</em> here). A <em>bias</em> is added to the result as the final output. There are also many people who argue that the bias here is meaningless and should removed. One line of code is sufficient for defining a variable:</p><p lang="zh-cn">看见了吧？16行上，我们用了一个<em>tf.nn.conv2d()</em>函数，它的参数是<em>input</em>，<em>filter</em>，<em>strides</em>，<em>padding</em>等等。顾名思义，这个函数就是用我们定义的权重Tensor<em>filter</em>（在这里称之为卷积核）来与这一层的输入input做了一次运算。运算的结果加上了偏置Tensor<em>bias</em>，作为这个卷积层的最终输出。很多人认为这里的偏置bias意义不明，因此他们在卷积之后没有加上这样的一个bias变量。定义一个变量只需要这样一个语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.Variable(tf.truncated_normal(shape, stddev=sigma), dtype=tf.float32, name=suffix)</span><br></pre></td></tr></table></figure><br><p lang="en-us">To define weight or bias variables, create a <em>tf.Variable</em> object. Usually you&#39;ll need to give the <em>initial_value</em> which also decides the shape of this tensor. <em>tf.truncated_normal()</em> and <em>tf.constant()</em> are usually used as the initial values. Also, other APIs - function <em>tf.get_variable()</em> and package <em>tf.initializers</em> are frequently used when using some more methods for initialization. I strongly recommend that you try using these APIs yourself.</p><p lang="zh-cn">要定义权重或者偏置变量，请创建一个<em>tf.Variable</em>对象。通常情况下，你会需要给出<em>initial_value</em>（TF变量的初始值），这将顺便定义了这个变量的shape（因为初始值的shape是确定的）。另外，一些新的API——<em>tf.get_variable()</em>函数和<em>tf.initializers</em>包也常用与的参数初始化，以实现更多样的初始化方法。我强烈建议自己动手实践一下，试一试这些API。</p><h3 id="3-2-Tensors-and-operations"><a href="#3-2-Tensors-and-operations" class="headerlink" title="3.2 Tensors and operations"></a>3.2 Tensors and operations</h3><p lang="en-us">Going on with the parameters of the <em>tf.nn.conv2d()</em> function. The required parameters also include <em>strides</em> and <em>padding</em>. You should have already learned about what strides mean in convolution, and I&#39;ll only talk about their formats. <em>strides</em> require a 1-D vector with a length of 4, like [1, 2, 2, 1]. The 1st and the 4th number is always 1(in order to match dimensions with the input), while the 2nd and the 3rd means the vertical stride and the horizonal stride.<br>The 4th parameter <em>padding</em> is a little bit different from its definition in convolution operation. It requires &#39;SAME&#39; of &#39;VALID&#39;, denoting &#39;with&#39; or &#39;without&#39; zero paddings. When it&#39;s &#39;SAME&#39;, zero padding is introduced to make the shapes match as needed, equally on every side of the input map.</p><p lang="zh-cn">接着说<em>tf.nn.conv2d()</em>函数的参数。需要的参数还包括<em>strides</em>和<em>padding</em>。你应该在了解卷积运算时学过stride（步幅）含义，我只说一下它的格式吧。<em>strides</em>参数需要是一个1维、长度为4的向量。第一位和第四位永远都是1，第二位和第三位分别是竖直方向和水平方向的步幅长。维持这个形式只是为了与输入的数据维度匹配，因此API看起来非常蹩脚。第四个参数<em>padding</em>和卷积运算里的padding不太相同。它的值只能是&#39;SAME&#39;或&#39;VALID&#39;，分别代表“带”和“不带”零补全。如果是&#39;SAME&#39;的话，函数会均匀地在图像的上下左右使用零补全来使得运算结果与之前尽可能保持一致。（stride&gt;1时有可能输出尺寸不是正好等于原来的尺寸/stride，因为补全问题）</p><p lang="en-us">tf.nn.conv2d() is just an example of TensorFlow <em>operations</em>. Other functions like <em>tf.matmul()</em>, <em>tf.reduce_mean()</em>, <em>tf.global_variables_initializer()</em>, <em>tf.losses.softmax_cross_entropy()</em>, <em>tf.truncated_normal()</em> are all operations. Operation functions return tensors(<em>tf.truncated_normal</em> also return a tensor, a tensor with initializers).</p><p lang="zh-cn">tf.nn.conv2d()只是TensorFlow运算（<em>operation</em>）的一个例子。其他例如<em>tf.matmul()</em>，<em>tf.reduce_mean()</em>，<em>tf.nn.relu()</em>，<em>tf.batch_normalization()</em>，<em>tf.global_variables_initializer()</em>，<em>tf.losses.softmax_cross_entropy()</em>，<em>tf.truncated_normal()</em>之类的函数也都是TensorFlow的运算。TensorFlow的运算函数会返回一个Tensor对象（包括<em>tf.truncated_normal()</em>也是！它只不过返回的是一个带初始化器的Tensor而已）。</p><p lang="en-us">All the functions in the TensorChain class are based on the most basic TensorFlow operations and variables. After learning about these basic TensorFlow concepts, actually you can already abandon TensorChain, go and try implementing your own neural networks yourself<br></p><p lang="zh-cn">TensorChain类中的所有成员函数都是基于最基本的TensorFlow运算和变量的。实际上，了解了这些，你现在已经可以抛开TensorChain的束缚，去尝试实现你自己的神经网络了！</p><h2 id="4-Spices"><a href="#4-Spices" class="headerlink" title="4 Spices"></a>4 Spices</h2><p lang="en-us">I&#39;m not joking just now! But I know that there are a lot of things that you still don&#39;t understand about using TensorFlow - like &quot;how do I visualize my computation graph&quot;, &quot;how do I save/load my model to/from files&quot;, &quot;how do I record some tensors&#39; values while training&quot; or &quot;how do I view the loss curves&quot; - after all TensorFlow APIs are far more complicated than just building those nets. Those are also important techniques in your research. If you&#39;d rather ask me than spending some time experimenting, please go on with reading.</p><p lang="zh-cn">我，我真没开玩笑！但是我知道关于如何使用TensorFlow，你还有许许多多的问题，好比“如何可视化地查看我的计算图结构”、“如何存储/读取模型文件”、“如何记录训练过程中某些Tensor的真实值”、“如何查看损失函数的变化曲线”——毕竟TensorFlow的API太复杂了，远比搭建神经网络那点函数复杂得多。上边说的那些是你使用TensorFlow研究过程中的重要技巧。如果你愿意听我讲而不想花些时间尝试的话，请继续读下去。</p><h3 id="4-1-Saving-and-loading-your-model"><a href="#4-1-Saving-and-loading-your-model" class="headerlink" title="4.1 Saving and loading your model"></a>4.1 Saving and loading your model</h3><p lang="en-us">The very first thing that you may want to do - after training a network model with nice outcomes - would be saving it. Saving a model is fairly easy - just use a <em>tf.train.Saver</em> object. See my code below:</p><p lang="zh-cn">训练出一个看起来输出还不错的神经网络模型后你想做的第一件事恐怕就是把它存下来了吧？保存模型其实非常简单：只要用一个<em>tf.train.Saver</em>类的对象。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="comment"># Train it for some iterations</span></span><br><span class="line">    <span class="comment"># Train it for some iterations</span></span><br><span class="line">    <span class="comment"># Train it for some iterations</span></span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    saver.save(session, <span class="string">'models/model.ckpt'</span>)</span><br></pre></td></tr></table></figure><br><p lang="en-us">I saved my model and variable values to &#39;models/model.ckpt&#39;. But actually, you&#39;ll find 3 files in the &#39;models&#39; directory - <em>model.ckpt.data-00000-of-00001</em>, <em>model.ckpt.meta</em> and <em>model.ckpt.index</em> - none of which is &#39;model.ckpt&#39;! That&#39;s because TensorFlow stores the graph structure separately from variables values. The <em>.meta</em> file describes the saved graph structure; the <em>.index</em> file records the mappings between tensor names and tensor metadata; and the <em>.data-00000-of-00001</em> file - which is always the biggest one - saves all the variable values. If you need the graph data together with the variable values to be loaded, use a Saver to load after creating a session:</p><p lang="zh-cn">我把我的模型和变量值存到了&#39;models/model.ckpt&#39;文件里。但是！实际上在models目录里你会找到三个文件：<em>model.ckpt.data-00000-of-00001</em>，<em>model.ckpt.meta</em>和<em>model.ckpt.index</em>——哪个也不是model.ckpt呀？那是因为TensorFlow把计算图的结构和图中各种变量的值分开存放了。<em>.meta</em>文件描述计算图的结构；<em>.index</em>文件记录各个Tensor名称（是name属性，而不是变量名）与Tensor元信息之间的映射；<em>.data-00000-of-00001</em>文件往往是最大的一个，它存储的是各个TensorFlow变量的实际值。如果读取时需要把图结构和变量值都读进来，在session创建以后，同样用一个Saver来读取即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    saver.restore(session, <span class="string">'models/model.ckpt'</span>)</span><br><span class="line">    <span class="comment"># Then continue doing everything just like the model is just trained</span></span><br></pre></td></tr></table></figure><br><p lang="en-us">Remember that session.run(tf.global_variables_initializer()) shouldn&#39;t be executed, since variables are already initialized with your saved <em>.data-0000-of-00001</em> file.If you only need the graph to be loaded, only use the <em>.meta</em> file:</p><p lang="zh-cn">记住，这时候就不要再去执行session.run(tf.global_variables_initializer())了，因为变量已经用存储的checkpoint文件内容初始化过了。如果只需要读取计算图结构，只要读取<em>.meta</em>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    tf.train.import_meta_graph(<span class="string">'models/model.ckpt.meta'</span>)</span><br><span class="line">    <span class="comment"># Then continue doing everything just like the model is just built</span></span><br></pre></td></tr></table></figure><br><p lang="en-us">Function <em>tf.train.import_meta_graph()</em> loads(appends) the graph to your current computation graph. The values of tensors are still uninitialized so you&#39;ll have to execute session.run(tf.global_variables_initializer()) again. The tensors that you defined in the model can be retrieved by their names(property of the Tensor objects, instead of Python variable names). For example:</p><p lang="zh-cn"><em>tf.train.import_meta_graph()</em>函数将文件里的计算图读到（添加到）你当前的计算图中。其中所有Tensor的值仍未初始化，所以有必要执行一下session.run(tf.global_variables_initializer())了。之前定义的变量可以按照名称取回，示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="comment"># Recover the model here</span></span><br><span class="line"></span><br><span class="line">    graph = tf.get_default_graph()</span><br><span class="line">    image_tensor = graph.get_tensor_by_name(<span class="string">'input_image:0'</span>)</span><br><span class="line">    loss = graph.get_tensor_by_name(<span class="string">'loss:0'</span>)</span><br><span class="line">    train = graph.get_operation_by_name(<span class="string">'train)</span></span><br></pre></td></tr></table></figure><br><p lang="en-us">To retrieve normal tensors, you&#39;ll have to append a <em>&#39;:0&#39;</em> to the name of the op. This means getting the associated tensor of the op. <em>train</em> is a little special - we only need the op, so the function is <em>get_operation_by_name()</em> so the &#39;:0&#39; is not necessary.</p><p lang="zh-cn">要取回一般的Tensor，需要在Tensor的name属性值后边加一个<em>&#39;:0&#39;</em>，意思是取这个运算对应的Tensor。训练操作<em>train</em>略有不同——我们要的就只是这个op，所以用的函数<em>get_operation_by_name()</em>跟其他Tensor不一样，而且&#39;:0&#39;也不需要加。</p><p lang="en-us" align="center">[THIS SECTION IS UNDER CONSTRUCTION]</p><p lang="zh-cn" align="center">[本部分内容施工中]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML&quot; async&gt;&lt;/script&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p lang=&quot;en-us&quot;&gt;
TensorFlow is a powerful open-source deep learning framework, supporting various languages including Python. However, its APIs are far too complicated for a beginner in deep learning(especially those who are new to Python). In order to ease the pain of having to understand the mess of various elements in TensorFlow computation graphs, I made this tutorial to help beginners take the first bite of the cake.&lt;br&gt;ResNets are one of the greatest works in the deep learning field. Although they look scary with extreme depths, it&amp;#39;s not a hard job to implement one. Now let&amp;#39;s build one of the simplest ResNets - ResNet-56, and train it on the CIFAR-10 dataset.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://linkinpark213.com/tags/Deep-Learning/"/>
    
      <category term="DIY" scheme="http://linkinpark213.com/tags/DIY/"/>
    
  </entry>
  
  <entry>
    <title>MathJax - Use Math in Hexo, Just Like Tex! (Including Problem Solutions)</title>
    <link href="http://linkinpark213.com/2018/04/24/mathjax/"/>
    <id>http://linkinpark213.com/2018/04/24/mathjax/</id>
    <published>2018-04-24T06:43:41.000Z</published>
    <updated>2018-04-24T08:59:11.947Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><p>Sometimes you may want to explain some algorithms or principles with beautiful formulae in your blog. How to do this? Edit them in Microsoft Word, take a screenshot, crop it and put it in the blog post? When you finish your article and find out that you missed a symbol in the pictures - oh man, gotta repeat that again? Stop using those images now! A beautiful math display engine - MathJax allows you to code math like a coder.</p><div style="font-size: 1.2em">$$\mathcal{C}\phi \delta e \mathfrak{M}\alpha th \mathit{I}n \mathcal{H}ex\sigma \mathbb{N}o\omega!$$</div><a id="more"></a><h2 id="1-Installation"><a href="#1-Installation" class="headerlink" title="1 Installation"></a>1 Installation</h2><h3 id="1-1-With-npm-For-those-using-Hexo-like-me"><a href="#1-1-With-npm-For-those-using-Hexo-like-me" class="headerlink" title="1.1 With npm (For those using Hexo like me)"></a>1.1 With npm (For those using Hexo like me)</h3><p>First, install <em>hexo-math</em> in your Hexo blog directory.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-math --save</span><br></pre></td></tr></table></figure></p><p>Then, add <em>math</em> configurations in your <em>_config.yml</em> file.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  engine:</span> <span class="string">'mathjax'</span></span><br></pre></td></tr></table></figure></p><p>Finally, also add to your <em>_config.yml</em> file in the <strong>theme directory</strong> these configurations below.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML</span></span><br></pre></td></tr></table></figure></p><h3 id="1-2-Or-by-inserting-a-snippet-in-your-HTML-code"><a href="#1-2-Or-by-inserting-a-snippet-in-your-HTML-code" class="headerlink" title="1.2 Or by inserting a snippet in your HTML code"></a>1.2 Or by inserting a snippet in your HTML code</h3><p>Maybe you don&#39;t have to use math in every blog post. If so, insert the following snippet in your Markdown file also works.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML'</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2 Usage"></a>2 Usage</h2><p>MathJax supports the same grammar that LaTeX does. To learn more about LaTeX, please refer to Chapter 3 of <a href="https://tobi.oetiker.ch/lshort/lshort.pdf" target="_blank" rel="noopener">The Not So ShortIntroduction to LATEX</a>(CN version also available <a href="http://www.mohu.org/info/lshort-cn.pdf" target="_blank" rel="noopener">here</a>).</p><p>Use a &quot;\\(&quot; and a &quot;\\)&quot; to insert a formula in the line(they decide the boundary of the formula), or two &quot;$$&quot; to insert one that occupy a new line. I&#39;ll give a few examples below.</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\(\mathcal&#123;F&#125;(x)=\mathcal&#123;H&#125;(x)-x\\)</span><br></pre></td></tr></table></figure><p>\(\mathcal{F}(x)=\mathcal{H}(x)-x\<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\(E=mc^2\\)</span><br></pre></td></tr></table></figure></p><p>\(E=mc^2\<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\lim_&#123;n\rightarrow \infty&#125;(1+2^n+3^n)^\frac&#123;1&#125;&#123;x+\sin n&#125;$$</span><br></pre></td></tr></table></figure></p><p>$$\lim_{n\rightarrow \infty}(1+2^n+3^n)^\frac{1}{x+\sin n}$$<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\mathcal&#123;C&#125;\phi \delta e \mathfrak&#123;M&#125;\alpha th \mathit&#123;I&#125;n \mathcal&#123;H&#125;ex\sigma \mathbb&#123;N&#125;o\omega!$$</span><br></pre></td></tr></table></figure></p><p>$$\mathcal{C}\phi \delta e \mathfrak{M}\alpha th \mathit{I}n \mathcal{H}ex\sigma \mathbb{N}o\omega!$$</p><h2 id="3-Problems-when-using-MathJax-with-Hexo-amp-Solutions"><a href="#3-Problems-when-using-MathJax-with-Hexo-amp-Solutions" class="headerlink" title="3 Problems when using MathJax with Hexo &amp; Solutions"></a>3 Problems when using MathJax with Hexo &amp; Solutions</h2><p>This list will be appended whenever I find any more.</p><h3 id="3-1-Subscript-symbol-quot-quot-gets-mistaken-as-Markdown-emphasize-symbol"><a href="#3-1-Subscript-symbol-quot-quot-gets-mistaken-as-Markdown-emphasize-symbol" class="headerlink" title="3.1 Subscript symbol &quot;_&quot; gets mistaken as Markdown emphasize symbol"></a>3.1 Subscript symbol &quot;_&quot; gets mistaken as Markdown emphasize symbol</h3><p>This is a tough problem. Hexo renderer would first render the .md file into a .html file, and the MathJax script will only work on the .html file. Therefore, when there are multiple subscript symbols, they might be rendered as &lt;em&gt;&lt;/em&gt; tags. </p><p>For example: when you actually need a full-line formula \(x_{i+1}+y_j\), perhaps you&#39;ll get a &quot;$$x<em>{i+1}+y</em>j$$&quot; instead. Look into the HTML code and you&#39;ll understand why.</p><p>My solution for now, is giving up this Markdown emphasize symbol, since both &quot;_&quot; and &quot;*&quot; can be used as emphasize tags, and the alternative symbol &quot;*&quot; will also work if we remove &quot;_&quot;. Using &quot;\_&quot; also works, but it would be frequently used(while &quot;*&quot; isn&#39;t), thus turning our math code into mess code.</p><p>How do we do this? Bravely look into the <em>node_modules</em> directory and find the renderer of the Hexo engine. My renderer is <em>marked</em>, which is the default for Hexo. There is a file named <em>marked.js</em> inside <em>node_modules/marked/lib/</em> directory. You can find two appearances of &quot;em:&quot;. Like this:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inline = &#123;</span><br><span class="line">  ...</span><br><span class="line">  em: <span class="regexp">/^\b_((?:[^_]|__)+?)_\b|^\*((?:\*:\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>and<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline.pedantic = merge(&#123;&#125;, inline.normal, &#123;</span><br><span class="line">  ...</span><br><span class="line">  em: <span class="regexp">/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Modify the regular expression after them - remove the one about &quot;_&quot;s and leave the one about &quot;*&quot;s. The new version would be:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inline = &#123;</span><br><span class="line">  ...</span><br><span class="line">  em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>and<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline.pedantic = merge(&#123;&#125;, inline.normal, &#123;</span><br><span class="line">  ...</span><br><span class="line">  em: <span class="regexp">/^\*(?=\S)([\s\S]*?\S)\*(?!\*)/</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>From now on, you can use &quot;_&quot; as the subscript in MathJax freely. You don&#39;t have to worry about its becoming &lt;em&gt;&lt;/em&gt; tags anymore.</p><h3 id="3-2-Using-quot-amp-quot-for-aligning-multi-line-equations-but-getting-a-quot-Misplaced-amp-quot"><a href="#3-2-Using-quot-amp-quot-for-aligning-multi-line-equations-but-getting-a-quot-Misplaced-amp-quot" class="headerlink" title="3.2 Using &quot;&amp;&quot; for aligning multi-line equations but getting a &quot;Misplaced &amp;&quot;"></a>3.2 Using &quot;&amp;&quot; for aligning multi-line equations but getting a &quot;Misplaced &amp;&quot;</h3><p>For example, in my previous post about ResNet, I tried to use the following code to start a new line in an equation while aligning the lines to the equal sign:<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x<span class="emphasis">_l&#125;&#125; &amp; = \frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x_</span>L&#125;&#125;\frac&#123;\partial&#123;x<span class="emphasis">_L&#125;&#125;&#123;\partial&#123;x_</span>l&#125;&#125;\\\\</span><br><span class="line">&amp; = \frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x<span class="emphasis">_L&#125;&#125;\Big(1+\frac&#123;\partial&#123;&#125;&#125;&#123;\partial&#123;x_</span>l&#125;&#125;\sum<span class="emphasis">_&#123;i=l&#125;^&#123;L-1&#125;\mathcal&#123;F&#125;(x_</span>i,\mathcal&#123;W&#125;_i)\Big)$$</span><br></pre></td></tr></table></figure></p><p>The &quot;&amp;&quot; symbols were used to align the lines to a certain point. However, the result was a &quot;Misplaced &amp;&quot; prompt.</p><p>By disabling MathJax, I found out that the rendered equation was correct, which means that <strong>the problem isn&#39;t with Hexo renderer</strong>. This was when I realized that although<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure></p><p>are not necessary,<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;split&#125;</span><br><span class="line">\end&#123;split&#125;</span><br></pre></td></tr></table></figure></p><p>shouldn&#39;t be removed. Surround the equation with them will work. My code is here:<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;split&#125;</span><br><span class="line">\frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x<span class="emphasis">_l&#125;&#125; &amp; = \frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x_</span>L&#125;&#125;\frac&#123;\partial&#123;x<span class="emphasis">_L&#125;&#125;&#123;\partial&#123;x_</span>l&#125;&#125;\\\\</span><br><span class="line">&amp; = \frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x<span class="emphasis">_L&#125;&#125;\Big(1+\frac&#123;\partial&#123;&#125;&#125;&#123;\partial&#123;x_</span>l&#125;&#125;\sum<span class="emphasis">_&#123;i=l&#125;^&#123;L-1&#125;\mathcal&#123;F&#125;(x_</span>i,\mathcal&#123;W&#125;_i)\Big)</span><br><span class="line">\end&#123;split&#125;$$</span><br></pre></td></tr></table></figure></p><p>And it runs like:$$\begin{split}\frac{\partial{\mathcal{E}}}{\partial{x_l}} &amp; = \frac{\partial{\mathcal{E}}}{\partial{x_L}}\frac{\partial{x_L}}{\partial{x_l}}\\&amp; = \frac{\partial{\mathcal{E}}}{\partial{x_L}}\Big(1+\frac{\partial{}}{\partial{x_l}}\sum_{i=l}^{L-1}\mathcal{F}(x_i,\mathcal{W}_i)\Big)\end{split}$$</p><h3 id="3-3-To-be-continued"><a href="#3-3-To-be-continued" class="headerlink" title="3.3 To be continued"></a>3.3 To be continued</h3><p>If you encounter other issues while using MathJax with Hexo(with or without a solution), feel free to leave a comment below!</p>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML&quot; async&gt;&lt;/script&gt;

&lt;p&gt;Sometimes you may want to explain some algorithms or principles with beautiful formulae in your blog. How to do this? Edit them in Microsoft Word, take a screenshot, crop it and put it in the blog post? When you finish your article and find out that you missed a symbol in the pictures - oh man, gotta repeat that again? Stop using those images now! A beautiful math display engine - MathJax allows you to code math like a coder.&lt;/p&gt;
&lt;div style=&quot;font-size: 1.2em&quot;&gt;
$$\mathcal{C}\phi \delta e \mathfrak{M}\alpha th \mathit{I}n \mathcal{H}ex\sigma \mathbb{N}o\omega!$$
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Blogging" scheme="http://linkinpark213.com/tags/Blogging/"/>
    
  </entry>
  
  <entry>
    <title>A Review of ResNet - Residual Networks</title>
    <link href="http://linkinpark213.com/2018/04/22/resnet/"/>
    <id>http://linkinpark213.com/2018/04/22/resnet/</id>
    <published>2018-04-22T06:55:35.000Z</published>
    <updated>2018-04-24T08:23:16.165Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h2 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0 Introduction"></a>0 Introduction</h2><p>Deep learning researchers have been constructing skyscrapers in recent years. Especially, VGG nets and GoogLeNet have pushed the depths of convolutional networks to the extreme. But questions remain: if time and money aren&#39;t problems, are deeper networks always performing better? Not exactly.</p><p>When residual networks were proposed, researchers around the world was stunned by its depth. &quot;Jesus Christ! Is this a neural network or the Dubai Tower?&quot; But <strong>don&#39;t be afraid!</strong> These networks are deep but the structures are simple. Interestingly, these networks not only defeated all opponents in the classification, detection, localization challenges in ImageNet 2015, but were also the main innovation in the best paper of CVPR2016.</p><div align="center">    <img src="/images/resnet/network_growth.jpg" width="40%" height="40%" alt="Network Growth"></div><a id="more"></a><h2 id="1-The-Crisis-Degradation-of-Deep-Networks"><a href="#1-The-Crisis-Degradation-of-Deep-Networks" class="headerlink" title="1 The Crisis: Degradation of Deep Networks"></a>1 The Crisis: Degradation of Deep Networks</h2><p>VGG nets proved the beneficial of representation depth of convolutional neural networks, at least within a certain range, to be exact. However, when Kaiming He et al. tried to deepen some plain networks, the training error and test error stopped decreasing after the network reached a certain depth(which is not surprising) and soon degraded. This is not an overfitting problem, because training errors also increased; nor is it a gradient vanishing problem, because there are some techniques(e.g. batch normalization[4]) that ease the pain.</p><div align="center" class="figure">    <img src="/images/resnet/downgrade.png" width="60%" height="60%" alt="The Downgrade Problem">    Fig.1 The downgrade problem<br></div><p>What seems to be the cause of this degradation? Obviously, deeper neural networks are more difficult to train, but that doesn&#39;t mean deeper neural networks would yield worse results. To explain this problem, Balduzzi et al.[3] identified shattered gradient problem - as depth increases, gradients in standard feedforward networks increasingly resemble white noise. I will write about that later.</p><h2 id="2-A-Closer-Look-at-ResNet-The-Residual-Blocks"><a href="#2-A-Closer-Look-at-ResNet-The-Residual-Blocks" class="headerlink" title="2 A Closer Look at ResNet: The Residual Blocks"></a>2 A Closer Look at ResNet: The Residual Blocks</h2><p>As the old saying goes, &quot;千里之行，始于足下&quot;. Although ResNets are as deep as a thousand layers, they are built with these basic residual blocks(the right part of the figure). </p><div align="center" class="figure">    <img src="/images/resnet/residual_blocks.png" width="50%" height="50%" alt="Comparison between normal weight layers and residual blocks">    Fig.2 Parts of plain networks and a residual block(or residual unit)<br></div><h3 id="2-1-Skip-Connections"><a href="#2-1-Skip-Connections" class="headerlink" title="2.1 Skip Connections"></a>2.1 Skip Connections</h3><p>In comparison, basic units of plain network models would look like the one on the left: one ReLU function after a weight layer(usually also with biases), repeated several times. Let&#39;s denote the desired underlying mapping(the ideal mapping) of the two layers as \(\mathcal{H}(x)\), and the real mapping as \(\mathcal{F}(x)\). Clearly, the closer \(\mathcal{F}(x)\) is to \(\mathcal{H}(x)\), the better it fits.</p><p>However, He et al. explicitly let these layers fit a residual mapping instead of the desired underlying mapping. This is implemented with &quot;shortcut connections&quot;, which skip one or more layers, simply performing identity mappings and getting added to the outputs of the stacked weight layers. This way, \(\mathcal{F}(x)\) would not try to fit \(\mathcal{H}(x)\), but \(\mathcal{H}(x)-x\). The whole structure(from the identity mapping branch, to merging the branches by the addition operation) are named &quot;residual blocks&quot;(or &quot;residual units&quot;).</p><p>What&#39;s the point in this? Let&#39;s do a simple analysis. The computation done by the original residual block is: $$y_l=h(x_l)+\mathcal{F}(x_l,\mathcal{W}_l),$$ $$x_{l+1}=f(y_l).$$</p><p>Here are the definitions of symbols:<br>\(x_l\): input features to the \(l\)-th residual block;<br>\(\mathcal{W}_{l}={W_{l,k}|_{1\leq k\leq K}}\): a set of weights(and biases) associated with the \(l\)-th residual unit. \(K\) is the number of layers in this block;\(\mathcal{F}(x,\mathcal{W})\): the residual function, which we talked about earlier. It&#39;s a stack of 2 conv. layers here;\(f(x)\): the activation function. We are using ReLU here;\(h(x)\): identity mapping.</p><p>If \(f(x)\) is also an identity mapping(as if we&#39;re not using any activation function), the first equation would become:$$x_{l+1}=x_l+\mathcal{F}(x_l,\mathcal{W}_l)$$</p><p>Therefore, we can define \(x_L\) recursively of any layer:$$x_L=x_l+\sum_{i=l}^{L-1}\mathcal{F}(x_i,\mathcal{W}_i)$$</p><p>That&#39;s not the end yet! When it comes to the gradients, according to the chain rules of backpropagation, we have a beautiful definition:$$\begin{split}\frac{\partial{\mathcal{E}}}{\partial{x_l}} &amp; = \frac{\partial{\mathcal{E}}}{\partial{x_L}}\frac{\partial{x_L}}{\partial{x_l}}\\&amp; = \frac{\partial{\mathcal{E}}}{\partial{x_L}}\Big(1+\frac{\partial{}}{\partial{x_l}}\sum_{i=l}^{L-1}\mathcal{F}(x_i,\mathcal{W}_i)\Big)\end{split}$$</p><p>What does it mean? It means that the information is directly backpropagated to ANY shallower block. This way, the gradients of a layer never vanish or explode even if the weights are too small or too big.</p><h3 id="2-2-Identity-Mappings"><a href="#2-2-Identity-Mappings" class="headerlink" title="2.2 Identity Mappings"></a>2.2 Identity Mappings</h3><p>It&#39;s important that we use identity mapping here! Just consider doing a simple modification here, for example, \(h(x)=\lambda_lx_l\)(\(\lambda_l\) is a modulating scalar). The definition of \(x_L\) and \(\frac{\partial{\mathcal{E}}}{\partial{x_l}}\) would become:$$x_L=(\prod_{i=l}^{L-1}\lambda_i)x_l+\sum_{i=l}^{L-1}(\prod_{j=i+1}^{L-1}\lambda_j)\mathcal{F}(x_i,\mathcal{W}_i)$$$$\frac{\partial{\mathcal{E}}}{\partial{x_l}}=\frac{\partial{\mathcal{E}}}{\partial{x_L}}\Big((\prod_{i=l}^{L-1}\lambda_i)+\frac{\partial{}}{\partial{x_l}}\sum_{i=l}^{L-1}(\prod_{j=i+1}^{L-1}\lambda_j)\mathcal{F}(x_i,\mathcal{W}_i)\Big)$$</p><p>For extremely deep neural networks where \(L\) is too large, \(\prod_{i=l}^{L-1}\lambda_i\) could be either too small or too large, causing gradient vanishing or gradient explosion. For \(h(x)\) with complex definitions, the gradient could be extremely complicated, thus losing the advantage of the skip connection. Skip connection works best under the condition where the grey channel in Fig. 3 cover no operations (except the addition) and is clean.</p><p>Interestingly, this comfirmed the philosophy of &quot;大道至简&quot; once again.</p><h3 id="2-3-Post-activation-or-Pre-activation"><a href="#2-3-Post-activation-or-Pre-activation" class="headerlink" title="2.3 Post-activation or Pre-activation?"></a>2.3 Post-activation or Pre-activation?</h3><p>Wait a second... &quot;\(f(x)\) is also an identity mapping&quot; is just our assumption. The activation function is still there!</p><p>Right. There IS an activation function, but it&#39;s moved to somewhere else.  In fact, the original residual block is still a little bit problematic - the output of one residual block is not always the input of the next, since there is a ReLU activation function after the addition(It did NOT REALLY keep the identity mapping to the next block!). Therefore, in[2], He et al. fixed the residual blocks by changing the order of operations.</p><div align="center" class="figure">    <img src="/images/resnet/identity_mapping.png" width="30%" height="30%" alt="New identity mapping">    Fig.3 New identity mapping proposed by He et al.<br></div><p>Besides using a simple identity mapping, He et al. also discussed about the position of the activation function and the batch normalization operation. Assuming that we got a special(asymmetric) activation function \(\hat f(x)\), which only affects the path to the next residual unit. Now our definition of \(x_{x+1}\) would become:$$x_{l+1}=x_l+\mathcal{F}(\hat f(x_l),\mathcal{W}_l)$$</p><p>With \(x_l\) still multiplied by 1, information is still fully backpropagated to shallower residual blocks. And the good thing is that using this asymmetric activation function after the addition(partial post-activation) is equivalent to using it beforehand(pre-activation)! This is why He et al. chose to use pre-activation - otherwise it would be necessary to implement that magical activation function \(\hat f(x)\).</p><div align="center" class="figure">    <img src="/images/resnet/pre-activation.png" width="80%" height="80%" alt="Asymmetric after-addition activation">    Fig.4 Using asymmetric after-addition activation is equivalent to constructing a pre-activation residual unit<br></div><h2 id="3-ResNet-Architectures"><a href="#3-ResNet-Architectures" class="headerlink" title="3 ResNet Architectures"></a>3 ResNet Architectures</h2><p>Here are the ResNet architectures for ImageNet. Building blocks are shown in brackets, with the numbers of blocks stacked. With the first block of every stack(starting from conv3_x), a downsampling is performed. Each column represents one of the residual networks, and the deepest one has 152 weight layers! Since ResNets were proposed, VGG nets - which were officially called &quot;Very Deep Convolutional Networks&quot; - are not relatively deep anymore. Maybe call them &quot;A Little Bit Deep Convolutional Networks&quot;.</p><div align="center" class="figure">    <img src="/images/resnet/architectures.png" width="80%" height="80%" alt="ResNet architectures for ImageNet">    Table. 1 ResNet architectures for ImageNet.<br></div><h2 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4 Experiments"></a>4 Experiments</h2><h3 id="4-1-Performance-on-ImageNet"><a href="#4-1-Performance-on-ImageNet" class="headerlink" title="4.1 Performance on ImageNet"></a>4.1 Performance on ImageNet</h3><p>He et al. trained ResNet-18 and ResNet-34 on the ImageNet dataset, and also compared them to plain convolutional networks. In Fig. 5, the thin curves denote training error, and the bold ones denote validation error. The figure on the left shows the results of plain convolution networks(in which the 34-layered ones has higher error rates than the 18-layered one), and the figure on the right shows that residual networks perform better than plain ones, while deeper ones perform better than shallow ones.</p><div align="center" class="figure">    <img src="/images/resnet/training.png" width="80%" height="80%" alt="Training ResNet on ImageNet">    Fig. 5 Training ResNet on ImageNet<br></div><h3 id="4-2-Effects-of-Different-Shortcut-Connections"><a href="#4-2-Effects-of-Different-Shortcut-Connections" class="headerlink" title="4.2 Effects of Different Shortcut Connections"></a>4.2 Effects of Different Shortcut Connections</h3><p>He et al. also tried various types of shortcut connections to replace the identity mapping, and various positions of activation functions / batch normalization. Experiments show that the original identity mapping and full pre-activation yield the best results.</p><div align="center" class="figure">    <img src="/images/resnet/shortcut-connections.png" width="50%" height="50%" alt="Different shortcuts of residual units">    Fig. 6 Various shortcuts in residual units<br>    <img src="/images/resnet/shortcut-connections-experiment.png" width="70%" height="70%" alt="Classification errors with different shortcuts">    Table. 2 Classification error on CIFAR-10 test set with various shortcut connections in residual units<br>    <img src="/images/resnet/activations.png" width="70%" height="50%" alt="Different usages of activation in residual units">    Fig. 7 Various usages of activation in residual units<br>    <img src="/images/resnet/activations-experiment.png" width="50%" height="50%" alt="Classification errors with different activations">    Table. 3 Classification error on CIFAR-10 test set with various usages of activation in residual units<br></div><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5 Conclusion"></a>5 Conclusion</h2><p>Residual learning can be crowned as &quot;ONE OF THE GREATEST HITS IN DEEP LEARNING FIELDS&quot;. With a simple identity mapping, it solved the degradation problem of deep neural networks. Now that you have learned about the concept of ResNet, why not give it a try and implement your first residual learning model today?</p><div align="center" class="figure">    <img src="/images/resnet/resnet-yooo.jpg" width="40%" height="40%" alt=""></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="http://openaccess.thecvf.com/content_cvpr_2016/papers/He_Deep_Residual_Learning_CVPR_2016_paper.pdf" target="_blank" rel="noopener">He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.</a></p><p>[2] <a href="https://arxiv.org/pdf/1603.05027.pdf" target="_blank" rel="noopener">He K, Zhang X, Ren S, et al. Identity mappings in deep residual networks[C]//European Conference on Computer Vision. Springer, Cham, 2016: 630-645.</a></p><p>[3] <a href="https://arxiv.org/pdf/1702.08591.pdf" target="_blank" rel="noopener">Balduzzi D, Frean M, Leary L, et al. The Shattered Gradients Problem: If resnets are the answer, then what is the question?[J]. arXiv preprint arXiv:1702.08591, 2017.</a></p><p>[4] <a href="https://arxiv.org/pdf/1502.03167.pdf" target="_blank" rel="noopener">Ioffe S, Szegedy C. Batch normalization: Accelerating deep network training by reducing internal covariate shift[J]. arXiv preprint arXiv:1502.03167, 2015.</a></p>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;0-Introduction&quot;&gt;&lt;a href=&quot;#0-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0 Introduction&quot;&gt;&lt;/a&gt;0 Introduction&lt;/h2&gt;&lt;p&gt;Deep learning researchers have been constructing skyscrapers in recent years. Especially, VGG nets and GoogLeNet have pushed the depths of convolutional networks to the extreme. But questions remain: if time and money aren&amp;#39;t problems, are deeper networks always performing better? Not exactly.&lt;/p&gt;
&lt;p&gt;When residual networks were proposed, researchers around the world was stunned by its depth. &amp;quot;Jesus Christ! Is this a neural network or the Dubai Tower?&amp;quot; But &lt;strong&gt;don&amp;#39;t be afraid!&lt;/strong&gt; These networks are deep but the structures are simple. Interestingly, these networks not only defeated all opponents in the classification, detection, localization challenges in ImageNet 2015, but were also the main innovation in the best paper of CVPR2016.&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/images/resnet/network_growth.jpg&quot; width=&quot;40%&quot; height=&quot;40%&quot; alt=&quot;Network Growth&quot;&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://linkinpark213.com/tags/Deep-Learning/"/>
    
      <category term="Computer Vision" scheme="http://linkinpark213.com/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>A Review of VGG net - Very Deep Convolutional Neural Networks</title>
    <link href="http://linkinpark213.com/2018/04/21/vgg/"/>
    <id>http://linkinpark213.com/2018/04/21/vgg/</id>
    <published>2018-04-21T08:15:55.000Z</published>
    <updated>2018-06-05T13:38:03.436Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h2 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0 Introduction"></a>0 Introduction</h2><p>Convolutional neural networks(CNN) have enjoyed great success in computer vision research fields in the past few years. A number of attempts are made based on the original CNN architecture to improve its accuracy and performance. In 2014, Karen Simonyan et al. did an investigation on the effect of depth on CNNs&#39; accuracy in large-scale image recognition (thus also proposing a series of very deep CNNs which are usually called VGG nets). The result confirmed the importance of CNN depth in visual representations.</p><h2 id="1-Background-VGG-net-39-s-ancestors"><a href="#1-Background-VGG-net-39-s-ancestors" class="headerlink" title="1 Background: VGG net&#39;s ancestors"></a>1 Background: VGG net&#39;s ancestors</h2><p>Before introducing VGG net, let&#39;s take a glance at prior convolutional neural networks. </p><h3 id="1-1-LeNet-The-Origin"><a href="#1-1-LeNet-The-Origin" class="headerlink" title="1.1 LeNet: The Origin"></a>1.1 LeNet: The Origin</h3><p>Basic neural network structures(for example, multi-layer perceptron) learn patterns on 1D vectors, which cannot cope with 2D features in images well. In 1986, Lecun et al. proposed a convolution network model called LeNet-5. Its structure is fairly simple: two convolution layers, two subsampling layers and a few fully connected layers. This network was used to solve a number recognition problem. (If you need to learn more about the convolution operation, please refer to Google or <em>Digital Image Processing</em> by Rafael C. Gonzalez)</p><a id="more"></a><div align="center" class="figure">    <img src="/images/vgg/lenet.png" width="80%" height="60%" alt="LeNet"><br>    Fig. 1 Architecture of LeNet<br></div><h3 id="1-2-AlexNet-The-Powerful-Convolution"><a href="#1-2-AlexNet-The-Powerful-Convolution" class="headerlink" title="1.2 AlexNet: The Powerful Convolution"></a>1.2 AlexNet: The Powerful Convolution</h3><p>In 2012, Alex Krizhevsky et al. won the first place in ILSVRC-2012(ImageNet Large-Scale Visual Recognition Challenge 2012) and achieved the highest top-5 error rate of 15.3% with a convolutional network model, while the second-best entry only achieved 26.2%. The network, namely AlexNet, was trained on two GTX580 3GB GPUs in parallel. Since a single GTX580 GPU has only 3GB memory, the maximum size of networks is limited. This model proved the effectiveness of CNNs under complicated circumstances and the power of GPUs. So what if the network can go deeper? Will the top-5 error rate get even lower?</p><div align="center" class="figure"><img src="/images/vgg/alexnet.png" alt="AlexNet"><br>Fig. 2 Architecture of AlexNet</div><h2 id="2-Main-Contributions-of-VGG-Nets"><a href="#2-Main-Contributions-of-VGG-Nets" class="headerlink" title="2 Main Contributions of VGG Nets"></a>2 Main Contributions of VGG Nets</h2><p>Here comes our hero - VGG nets. By the way, VGG is not the name of the network, but the name of the authors&#39; group - <em>Visual Geometry Group</em>, from Department of Engineering Science, University of Oxford. The networks they proposed were therefore named after the group. The main contributions of VGG nets are: 1. more but smaller convolution filters; 2. great depth of networks.</p><h3 id="2-1-Stacks-of-Smaller-Convolution-Filters"><a href="#2-1-Stacks-of-Smaller-Convolution-Filters" class="headerlink" title="2.1 Stacks of Smaller Convolution Filters"></a>2.1 Stacks of Smaller Convolution Filters</h3><p>Rather than using relatively large receptive fields in the first convolution layers, Simonyan et al. selected very small 3x3 receptive fields throughout the whole net, which are convolved with the input at every pixel with a stride of 1. As is shown in the figures below, a stack of two 3x3 convolution layers has an effective receptive field of 5x5. We can also conclude that a stack of three 3x3 convolution filters has an effective receptive field of 7x7.</p><div align="center" class="figure">    <img src="/images/vgg/conv1.png" width="50%" height="50%" alt="Conv5x5"><br>    Fig. 3 A convolution layer with one 5x5 conv. filter has a receptive field of 5x5<br>    <img src="/images/vgg/conv2.png" width="60%" height="60%" alt="Conv3x3x2"><br>    Fig. 4 A convolution layer stack with two 3x3 conv. filter also has a effective receptive field of 5x5<br></div><p>Now that we&#39;re clear that stacks of small-kernel convolution layers have equal sized receptive fields, why are they the better choice? Well, the first advantage is incorporating more rectification layers instead of a single one, since every convolution layer includes an activation function(usually ReLU). More rectification brings more non-linearity, and more non-linearity makes the decision function more discriminative and fit better. Also, when the receptive field isn&#39;t too large, a stack of 3x3 convolution filters have fewer parameters to train. Assuming the number of input and output channels of a convolution layer stack are equal(let&#39;s call it C) and the receptive field is 5x5, we have \(2*3*3*C*C=18C^2\) instead of \(5*5*C*C=25C^2\) parameters here. Similarly, when the receptive field is 7x7, we have \(3*3*3*C*C=27C^2\) instead of \(7*7*C*C=49C^2\). When the field gets even larger? A function with \(O(n)\) complexity only has greater advantage against an \(O(n^2)\) when \(n\) grows.</p><h3 id="2-2-Deep-Dark-Fantasy"><a href="#2-2-Deep-Dark-Fantasy" class="headerlink" title="2.2 Deep Dark Fantasy"></a>2.2 Deep Dark Fantasy</h3><p>Cliches time. Just like any blogger mentioning VGG nets would do, here are the network structures proposed by Simonyan et al.</p><div align="center" class="figure">    <img src="/images/vgg/vggnets.png" width="60%" height="60%" alt="VGG Nets"><br>    Table. 1 VGG nets of various depths<br></div><p>Look at the table column-by-column. Each column(A, A-LRN, B, C, D, E) corresponds to one network structure. As you can see, their networks grew from 11 layers(in net A) to 19 layers(in net E). Each time something is added to the previous net, it would appear bold. Clearly, LRN(Local Response Normalization) didn&#39;t work well in this case(actually, A-LRN net performed worse than A, while consuming much more memory and computation time), and was thus removed. </p><p>What&#39;s worth mentioning are the 1x1 convolution layers appearing in network C. This is a way to increase non-linearity(also by introducing activation functions) of the decision function while also keeping the size of the receptive fields unchanged.</p><h2 id="3-Training-amp-Evaluation"><a href="#3-Training-amp-Evaluation" class="headerlink" title="3 Training &amp; Evaluation"></a>3 Training &amp; Evaluation</h2><p>Bad initialization could stall learning due to the instability of gradient deep networks. Therefore, the authors first trained the network A, which is shallow enough to be trained with random initialization. Then, the next networks (B to E) are initialized with the pre-trained models, and only weights of the new layers are randomly initialized.</p><p>In spite of the larger number of parameters and the greater depth of our nets compared to AlexNet, the nets required less epochs to converge due to the implicit regularization imposed by greater depth, smaller convolution filter sizes and the pre-initialization of certain layers. They also generalize well to other datasets, achieving state-of-the-art performances. Results of VGG nets in comparison against other models in ILSVRC are shown in the table below.</p><div align="center" class="figure">    <img src="/images/vgg/VGG-performance-comparison.png" width="70%" height="70%" alt="VGG net results"><br>    Table. 2 VGG net performance, in comparison with the state of the art in ILSVRC classification<br></div><p>In conclusion, the representation depth is beneficial for the classification accuracy, and that state-of-the-art performance on the ImageNet challenge dataset can be achieved using a conventional ConvNet architecture (LeCun et al., 1989; Krizhevsky et al., 2012) with substantially increased depth. </p><p>You might ask: Why not even deeper, with more powerful GPUs(the authors used Titan Black), we can absolutely train deeper networks that perform better! Not exactly. Problems arose as the networks get too deep, and this is where ResNet comes in.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://arxiv.org/pdf/1409.1556/" target="_blank" rel="noopener">Simonyan K, Zisserman A. Very deep convolutional networks for large-scale image recognition[J]. arXiv preprint arXiv:1409.1556, 2014.</a></p>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;0-Introduction&quot;&gt;&lt;a href=&quot;#0-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0 Introduction&quot;&gt;&lt;/a&gt;0 Introduction&lt;/h2&gt;&lt;p&gt;Convolutional neural networks(CNN) have enjoyed great success in computer vision research fields in the past few years. A number of attempts are made based on the original CNN architecture to improve its accuracy and performance. In 2014, Karen Simonyan et al. did an investigation on the effect of depth on CNNs&amp;#39; accuracy in large-scale image recognition (thus also proposing a series of very deep CNNs which are usually called VGG nets). The result confirmed the importance of CNN depth in visual representations.&lt;/p&gt;
&lt;h2 id=&quot;1-Background-VGG-net-39-s-ancestors&quot;&gt;&lt;a href=&quot;#1-Background-VGG-net-39-s-ancestors&quot; class=&quot;headerlink&quot; title=&quot;1 Background: VGG net&amp;#39;s ancestors&quot;&gt;&lt;/a&gt;1 Background: VGG net&amp;#39;s ancestors&lt;/h2&gt;&lt;p&gt;Before introducing VGG net, let&amp;#39;s take a glance at prior convolutional neural networks. &lt;/p&gt;
&lt;h3 id=&quot;1-1-LeNet-The-Origin&quot;&gt;&lt;a href=&quot;#1-1-LeNet-The-Origin&quot; class=&quot;headerlink&quot; title=&quot;1.1 LeNet: The Origin&quot;&gt;&lt;/a&gt;1.1 LeNet: The Origin&lt;/h3&gt;&lt;p&gt;Basic neural network structures(for example, multi-layer perceptron) learn patterns on 1D vectors, which cannot cope with 2D features in images well. In 1986, Lecun et al. proposed a convolution network model called LeNet-5. Its structure is fairly simple: two convolution layers, two subsampling layers and a few fully connected layers. This network was used to solve a number recognition problem. (If you need to learn more about the convolution operation, please refer to Google or &lt;em&gt;Digital Image Processing&lt;/em&gt; by Rafael C. Gonzalez)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://linkinpark213.com/tags/Deep-Learning/"/>
    
      <category term="Computer Vision" scheme="http://linkinpark213.com/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>Smartypants is NOT SO SMART</title>
    <link href="http://linkinpark213.com/2018/03/20/smartypants/"/>
    <id>http://linkinpark213.com/2018/03/20/smartypants/</id>
    <published>2018-03-20T03:00:22.000Z</published>
    <updated>2018-04-22T15:15:12.339Z</updated>
    
    <content type="html"><![CDATA[<p>When blogging with Hexo, every time I type a single quotation mark(also called apostrophe) like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;</span><br></pre></td></tr></table></figure></p><p>, Hexo would convert it to a symbol like this<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">’</span><br></pre></td></tr></table></figure></p><p>You would say that this is also an apotrophe, but it really looks UNBEARABLE in the articles. It&#39;s been a problem bothering me for more than a month.(I&#39;m not saying that this is the reason for not updating my blog, but I don&#39;t mind if you think so!)</p><a id="more"></a><p><img src="/images/smartypants/apostrophe.png" alt="apostrophe"></p><p>Therefore, I Googled about this problem and tried to find other victims. According to their sharings, this problem is caused by <em>marked</em> -- the default markdown renderer of Hexo.The <em>&quot;smatrypants&quot;</em> function of marked was turned on by default.</p><p>Now take a look at the introduction of <em>smartypants</em> on the <em>hexo-renderer-marked</em> page:</p><blockquote><p><em>smartypants</em> - Use &quot;smart&quot; typograhic punctuation for things like quotes and dashes.</p></blockquote><p>C&#39;mon, seriously? </p><p>There are a few bloggers who solved this by adding the code below to the _config.yml file in the blog directory. </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mark:</span></span><br><span class="line"><span class="attr">  smartypants:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>This worked for most victims (perhaps all of them), but not for me. I have no idea why those config wasn&#39;t working, so if anyone finds out the reason, please contact me by e-mail.</p><p>If you&#39;re sure <em>smartypants</em> is causing the problem, and the solution above didn&#39;t work for you either, maybe you can try my solution.</p><p>Since <em>hexo-renderer-marked</em> is installed in the blog&#39;s <em>node_modules</em> directory(may also be in your Node.js directory if installed globally), isn&#39;t it possible that we change its own configurations? I looked at the <em>index.js</em> file in the <em>node_modules/hexo-renderer-marked/</em> directory. There you are, smartypants!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo.config.marked = assign(&#123;</span><br><span class="line">  gfm: <span class="literal">true</span>,</span><br><span class="line">  pedantic: <span class="literal">false</span>,</span><br><span class="line">  sanitize: <span class="literal">false</span>,</span><br><span class="line">  tables: <span class="literal">true</span>,</span><br><span class="line">  breaks: <span class="literal">true</span>,</span><br><span class="line">  smartLists: <span class="literal">true</span>,</span><br><span class="line">  smartypants: <span class="literal">true</span>,</span><br><span class="line">  modifyAnchors: <span class="string">''</span>,</span><br><span class="line">  autolink: <span class="literal">true</span></span><br><span class="line">&#125;, hexo.config.marked);</span><br></pre></td></tr></table></figure><p>Now you know what to do.</p><p>Aaaaaaaaaaaaaaaand many thanks to Xizi Wu, the artist of my new avatar! I love it<br><img src="/images/long_nobg.png" alt="Harper Long by Xizi Wu"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;When blogging with Hexo, every time I type a single quotation mark(also called apostrophe) like this:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;, Hexo would convert it to a symbol like this
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;’&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;You would say that this is also an apotrophe, but it really looks UNBEARABLE in the articles. It&amp;#39;s been a problem bothering me for more than a month.(I&amp;#39;m not saying that this is the reason for not updating my blog, but I don&amp;#39;t mind if you think so!)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blogging" scheme="http://linkinpark213.com/tags/Blogging/"/>
    
  </entry>
  
  <entry>
    <title>Cheers for the 8th International linkinpark213 Day!</title>
    <link href="http://linkinpark213.com/2018/02/13/linkinpark213-day/"/>
    <id>http://linkinpark213.com/2018/02/13/linkinpark213-day/</id>
    <published>2018-02-13T07:03:02.047Z</published>
    <updated>2018-03-20T12:23:12.255Z</updated>
    
    <content type="html"><![CDATA[<p>Cheers for the 8th International linkinpark213 Day!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'Harper'</span> <span class="string">'Sweet'</span> <span class="string">'Kobayashi'</span> <span class="string">'Kawasaki'</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"I'm <span class="variable">$i</span>, cheers!"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="What-is-linkinpark213-Day"><a href="#What-is-linkinpark213-Day" class="headerlink" title="What is linkinpark213 Day?"></a>What is linkinpark213 Day?</h2><p>International linkinpark213 Day is a global anniversary set up by Harper Long in 2011 A.D., celebrated on February 13th every year. This anniversary is officially written as &#39;linkinpark213 Day&#39;, the first letter of which is a lower-case. The establishment of the anniversary dates back to the early 10s in the 21st century.</p><p>Till now, the population for this anniversary has already reached 1e-6 million, and the distribution also expanded from a small county to the whole middle-China area, including Hebei, Henan, Shanxi and Shaanxi province. There will also be some Japanese resident who plan to celebrate this day in 2019.</p><a id="more"></a><h2 id="Why-13th-Feb"><a href="#Why-13th-Feb" class="headerlink" title="Why 13th Feb?"></a>Why 13th Feb?</h2><p>According to the modern Chinese habit of writing, &#39;13th Feb&#39; is usually written as &#39;2.13&#39;. Also, &#39;13&#39; and &#39;B&#39; look similar and are often regarded to be equal. In conclusion, &#39;13 Feb&#39; can be transformed to &#39;2B&#39;, which is a common word in Chinese. Although the word is sometimes classified as &quot;offensive&quot;, it reflects feelings of optimism, bravery and entertainment.</p><h2 id="How-do-people-celebrate-the-day"><a href="#How-do-people-celebrate-the-day" class="headerlink" title="How do people celebrate the day?"></a>How do people celebrate the day?</h2><p>When the anniversary was first set up, there was no officially specified ways of celebration. People gathered, held parties and enjoyed spending time together. </p><p>On the 3th linkinpark213 Day, a proposal by a high school Chinese teacher was taken as the official way of celebration -- on each linkinpark213 Day, a number of people participate in the Pigeon-Flying Competition funded by Harper Long. This way of celebration prevailed until now, and all participants except Harper Long won the competition every year.</p><p>Pigeon-Flying is a broadly-accepted traditional Chinese custom, the exact origin of which is too ancient to be revealed. Modern scholars tend to believe that this custom became well-known no later than 206 A.D. in China. In modern times, pigeon-flying is an activity involving &quot;making a promise&quot; and &quot;not keeping it&quot;. According to some folk stories, this activity was firstly named when it happened to a pigeon keeper when he forgot to keep a promise that he made with a friend. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Promise promise = <span class="keyword">new</span> Promise();</span><br><span class="line">    promise.make(<span class="string">"I will come!"</span>);</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">    promise.keep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Please notice that pigeon-flying mentioned here is not the same activity as what happens every Olympics since 1896 A.D.)</p><p>Join our celebration today! You can easily participate in the Pigeon-Flying Competition by not participating.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cheers for the 8th International linkinpark213 Day!&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Harper&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Sweet&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Kobayashi&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Kawasaki&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;I&#39;m &lt;span class=&quot;variable&quot;&gt;$i&lt;/span&gt;, cheers!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;What-is-linkinpark213-Day&quot;&gt;&lt;a href=&quot;#What-is-linkinpark213-Day&quot; class=&quot;headerlink&quot; title=&quot;What is linkinpark213 Day?&quot;&gt;&lt;/a&gt;What is linkinpark213 Day?&lt;/h2&gt;&lt;p&gt;International linkinpark213 Day is a global anniversary set up by Harper Long in 2011 A.D., celebrated on February 13th every year. This anniversary is officially written as &amp;#39;linkinpark213 Day&amp;#39;, the first letter of which is a lower-case. The establishment of the anniversary dates back to the early 10s in the 21st century.&lt;/p&gt;
&lt;p&gt;Till now, the population for this anniversary has already reached 1e-6 million, and the distribution also expanded from a small county to the whole middle-China area, including Hebei, Henan, Shanxi and Shaanxi province. There will also be some Japanese resident who plan to celebrate this day in 2019.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Other" scheme="http://linkinpark213.com/tags/Other/"/>
    
  </entry>
  
</feed>
